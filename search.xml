<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于Dockerfile</title>
    <url>/zh-CN/2025/AboutDockerfile/</url>
    <content><![CDATA[<p>主要记录学习过程</p>
<p>学到新东西了就来更新</p>
<p>Dockerfile有很多东西，这只是其中的一部分</p>
<span id="more"></span>
<p>Docker这东西说简单也不简单说难也不难</p>
<p>实际上不是一般不是Docker难而是你想在容器中跑的东西难配置</p>
<p>以下是一些实操</p>
<p>先来看一个别人写的Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.11</span>.<span class="number">11</span>-slim-bookworm as build</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PYTHONDONTWRITEBYTECODE=<span class="number">1</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED=<span class="number">1</span></span><br><span class="line"><span class="keyword">ENV</span> SET_CONTAINER_TIMEZONE=true</span><br><span class="line"><span class="keyword">ENV</span> CONTAINER_TIMEZONE=Asia/Shanghai</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> TARGETARCH</span><br><span class="line"><span class="keyword">ARG</span> VERSION</span><br><span class="line"><span class="keyword">ENV</span> VERSION=$&#123;VERSION&#125;</span><br><span class="line"><span class="keyword">ENV</span> PYTHON_IN_DOCKER=<span class="string">&#x27;PYTHON_IN_DOCKER&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> scripts/* /app/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get --allow-releaseinfo-change update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y --no-install-recommends jq chromium chromium-driver tzdata \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*  \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get clean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./requirements.txt /tmp/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /data \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">cd</span> /tmp \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; python3 -m pip install --upgrade pip \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; PIP_ROOT_USER_ACTION=ignore pip install \</span></span><br><span class="line"><span class="language-bash">    --disable-pip-version-check \</span></span><br><span class="line"><span class="language-bash">    --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">    -r requirements.txt \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /tmp/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; pip cache purge \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/log/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG=C.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>,<span class="string">&quot;main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>槽点很多，多到数不过来</p>
<p>直接看修改后</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.11</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PYTHONDONTWRITEBYTECODE=<span class="number">1</span> \</span><br><span class="line">    TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> scripts/* .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=requirements.txt,target=/tmp/requirements.txt \</span></span><br><span class="line"><span class="language-bash">    apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">    chromium \</span></span><br><span class="line"><span class="language-bash">    chromium-driver \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; pip install --no-cache-dir -r /tmp/requirements.txt \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>,<span class="string">&quot;main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>Python3.7后不再需要 <code>PYTHONUNBUFFERED</code></p>
<blockquote>
<p><a href="https://docs.python.org/3/using/cmdline.html#cmdoption-u">https://docs.python.org/3/using/cmdline.html#cmdoption-u</a></p>
</blockquote>
<p>Debian官方镜像只需要清理 <code>apt update</code> 时下载的目录即可</p>
<p>镜像中已经配置了自动清理deb包缓存</p>
<blockquote>
<p>在这个目录下 &#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;docker-clean</p>
</blockquote>
<p>对 <code>requirements.txt</code> 的调用换成了官方最佳实践的示例</p>
<blockquote>
<p><a href="https://docs.docker.com/build/building/best-practices/#add-or-copy">https://docs.docker.com/build/building/best-practices/#add-or-copy</a></p>
</blockquote>
<p>将 <code>CMD</code> 换成了 <code>ENTRYPOINT</code></p>
<blockquote>
<ul>
<li><a href="https://docs.docker.com/reference/dockerfile/#entrypoint">ENTRYPOINT</a></li>
<li><a href="https://docs.docker.com/reference/dockerfile/#shell-and-exec-form">Shell and exec form</a></li>
<li><a href="https://docs.docker.com/reference/compose-file/services/#init">init</a></li>
</ul>
</blockquote>
<p><code>jq</code> 这个包是用来在命令行中解析json的，很明显这里只有一个需要运行的python程序</p>
<p>我不知道为什么要加，反正删了没出问题</p>
<p>删除了一堆关于时区的配置，配置时区只需要使用 <code>TZ</code> 环境变量就行</p>
<p><code>TZ</code> 是linux自带的环境变量而不是Docker添加的</p>
<p>我对时区了解的不是很多，反正跑起来了不是吗</p>
<p>他在python程序里读取了环境变量中的版本号</p>
<p>其实版本号不只这个地方有与其发布版本的时候打进去不如手动改</p>
<p><code>FROM ... as ...</code> 这里的 <code>as</code> 记得写成 <code>AS</code></p>
<p>大小写要规范</p>
<p>其他案例可以看我的其他blog</p>
<p>之后再继续更新</p>
]]></content>
  </entry>
  <entry>
    <title>关于使用 ZeroTier 进行异地组网</title>
    <url>/zh-CN/2025/AboutZeroTier/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>以下内容仅适用于 ZeroTier 1.14</p>
</blockquote>
<p>ZeroTier 可以将设备添加至一个由 ZeroTier 网络控制器控制的虚拟局域网</p>
<p>通过协调服务器的协调来进行节点间的直连</p>
<p>当你在你的家庭服务器上部署了个人网盘&#x2F;密码托管&#x2F;即时通讯&#x2F;游戏服务器这样的服务时</p>
<p>想在楼下的餐馆里，其他城市的酒店里，你朋友的家里安全地访问到这些服务</p>
<p>这时候就可以使用 ZeroTier 来构建一个虚拟局域网</p>
<p>在国内环境下这种方案也可以降低一定的搭建个人信息平台时的法律风险</p>
<span id="more"></span>
<blockquote>
<p>关于国内ICP备案相关的信息我知道的不多</p>
<p>这种方式只是避免直接打开公网端口，降低一定的法律风险的同时封锁公网扫描的可能性</p>
<p>如果需要对公网部署还请购买云服务器，ICP备案针对的是服务器</p>
</blockquote>
<p>开讲之前先来点免责声明</p>
<p>以下内容皆为个人笔记绝对不是什么教程</p>
<p>主要是记录一些踩过的坑防止别人再踩一遍</p>
<p>以及我在编写前没有阅读过源码，如果有错误可以来仓库提个 issue</p>
<h2 id="异地组网"><a href="#异地组网" class="headerlink" title="异地组网"></a>异地组网</h2><p>异地组网的主要用途是对异地设备之间的流量进行加密</p>
<p>异地的两台设备在互相访问时会有大量数据经过公网</p>
<p>不对敏感数据进行加密无异于裸奔</p>
<p>SSL&#x2F;TLS 加密也可以完成这种任务，但需要搭建一个证书签发机构并在每个设备上手动信任</p>
<p>或购买域名来获得被信任的第三方机构签发的证书</p>
<p>这在小型网络中昂贵麻烦且无必要</p>
<p>而异地组网能以一个相对较低的成本完成这个任务</p>
<p>简单来说，就是换了一种方式去验证双方身份和加密数据</p>
<p>以目前主流的协议 <a href="https://www.wireguard.com/">WireGuard</a> 来说</p>
<p>双方需要提前知道对方的公钥才可以进行连接</p>
<p>虽然 WireGuard 本身已经可以进行组网，但对于日常使用还是有很多问题</p>
<p>组网软件简单来说就是对协议的一层包装，用来解决实际使用上的一些问题</p>
<p>比如公钥交换，在 NAT 下节点间的互连等</p>
<h2 id="软件选择"><a href="#软件选择" class="headerlink" title="软件选择"></a>软件选择</h2><p>目前主流的组网软件有 <a href="https://www.zerotier.com/">ZeroTier</a> <a href="https://tailscale.com/">Tailscale</a> 和 <a href="https://easytier.cn/">EasyTier</a></p>
<p>ZeroTier 基于自己的协议实现，而其他两家使用 WireGuard 作为通讯协议</p>
<p>三家其实各有各的特色</p>
<p>我个人不太喜欢 Tailscale 的管理模式，而且必须使用第三方账号注册使用，还得在每个设备上登录</p>
<p>EasyTier 看上去确实不错，可惜我有些 ZeroTier 的沉没成本在导致没有什么动力去尝试了</p>
<p>同时去中心化的设计也会造成一些问题，比如配置麻烦一类的</p>
<p>对于我来说 ZeroTier 的优点就是没有缺点，能以一个简单的方式满足我的需求</p>
<blockquote>
<p>当然其实有点，比如我对他的通讯协议这方面是真的没有一点头绪</p>
<p>以及我折腾好久才发现这东西原来点几个按钮就行之类的</p>
<p>写这篇文章就是因为这个</p>
</blockquote>
<p>我只是抛出一点选项来让你做对比，请结合自身情况来找到最适合你的选项</p>
<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>从这里开始算是笔记，作为对下面几个视频的补充</p>
<p><a href="https://www.bilibili.com/video/BV1Vh411F7Mr">内网穿透工具ZeroTier，从简单到复杂的玩法，无保留，一期全放送</a></p>
<p><a href="https://www.bilibili.com/video/BV1oL411Y7pB">这么良心的开源、内网穿透工具ZeroTier，为啥到你手就不好用了？</a></p>
<p>讲了一些视频里没提到的，我的建议是遇到问题再回来查一查有没有解决方案</p>
<p>简单的使用的话直接看第一个视频就行</p>
<h2 id="半自部署"><a href="#半自部署" class="headerlink" title="半自部署"></a>半自部署</h2><p>半自部署简单来说就是部署 <a href="https://docs.zerotier.com/controller">网络控制器</a></p>
<p>半自部署最大的好处是没有官方网络控制器的设备数和网络数上限，并不会有安全性的提升</p>
<p>因为连接的planet服务器依旧是别人的，在连接网络时使用的是 <strong>节点id+网络id</strong> 的格式</p>
<p>而节点id是由planet服务器分发的，理论上planet可以把你导向另外的控制器</p>
<blockquote>
<p>个人理解，总之就是planet上运行的代码对用户来说不透明，在使用其他人的提供的服务前请确认你信任他</p>
</blockquote>
<p>网络控制器控制着几乎所有的ZeroTier功能，比如IP分配，路由表和DNS配置下发</p>
<p>ZeroTier的客户端本身就拥有成为网络控制器的能力</p>
<blockquote>
<p>ZeroTier 1.16.0 中似乎将网络控制器移出了普通客户端 </p>
<p><a href="https://github.com/zerotier/ZeroTierOne/blob/dev/RELEASE-NOTES.md">https://github.com/zerotier/ZeroTierOne/blob/dev/RELEASE-NOTES.md</a></p>
<p>我还没有测试，官方教程似乎没有更新</p>
<p>2025&#x2F;09&#x2F;26</p>
</blockquote>
<p>你可以把他部署在一个始终在线的节点上，比如你家路由器</p>
<p>在连接到官方的网络管理界面 <a href="https://my.zerotier.com/">https://my.zerotier.com/</a> 时，实际上就是连接到了官方分配给你的节点</p>
<p>我在这个方案上花了很多时间，最后发现其实挺简单</p>
<p>只要部署 <a href="https://github.com/key-networks/ztncui">ztncui</a> 就行</p>
<p>详细看下方实操章节</p>
<h2 id="全自部署"><a href="#全自部署" class="headerlink" title="全自部署"></a>全自部署</h2><p>全自部署和半自部署的区别就是直接部署了自己的planet服务器</p>
<p>这样你可以看到所有你正在运行的代码，并且所有的数据和权限都在自己手里</p>
<p>这是社区制作的一键部署包 <a href="https://github.com/xubiaolin/docker-zerotier-planet">docker-zerotier-planet</a></p>
<p>他会同时部署planet服务器，moon服务器，网络控制器管理界面 <a href="https://github.com/key-networks/ztncui">ztncui</a>，以及官方客户端</p>
<p>但这个方案服务器ip变动时就需要进行重新部署，并且需要暴露端口</p>
<p>既然都暴露端口了，在我的情况下不如直接配置 <a href="https://github.com/jeessy2/ddns-go">ddns-go</a> ，解析到公网ipv6从公网连接到服务器</p>
<p>这个方案没什么好讲的，下载下来一键启动就行</p>
<h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><h2 id="ztncui"><a href="#ztncui" class="headerlink" title="ztncui"></a>ztncui</h2><blockquote>
<p>注意，ztncui的GitHub仓库上次更新时间是 <a href="https://github.com/key-networks/ztncui/commit/1b2284864de48d2dcae22582fff122fe24909c3d">2023.8.31</a></p>
</blockquote>
<p>我这里提供Docker的部署方法，因为我的环境不方便直接安装npm</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">23</span>-alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache git python3 build-base \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; git <span class="built_in">clone</span> --branch master --single-branch --depth 1 https://github.com/key-networks/ztncui.git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /ztncui/src</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm -g install node-gyp \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; npm install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">23</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /ztncui /ztncui</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /ztncui/src</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>,<span class="string">&quot;start&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">ztncui:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ztncui</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_ALL_INTERFACES=yes</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./passwd:/ztncui/src/etc/passwd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/lib/zerotier-one/authtoken.secret:/var/lib/zerotier-one/authtoken.secret</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个文件一个是web面板的用户密码，一个是ZeroTier客户端的访问密钥</p>
<p>默认端口 <code>3000</code>，能用 <code>HTTP_PORT=3456</code> 改</p>
<p><code>HTTP_ALL_INTERFACES</code> 意思是任何ip地址都能访问，方便nginx反向代理</p>
<p>详细设置请看官方仓库 <a href="https://github.com/key-networks/ztncui">ztncui</a></p>
</blockquote>
<p>所有功能都是官方客户端实现的，所以配置文件只有密码</p>
<p>启动后打开网页点左上角的 <code>Add network</code> 就可以添加网络</p>
<p>少量设备其实没必要使用这个功能，而且在我的情况下必须先连接到网络才能打开管理面板</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>ZeroTier虽然不需要去在意节点本身的ip地址，但连接其他节点时使用的还是虚拟内网中的ip地址</p>
<p>如果不想记忆ip地址，想使用域名访问服务器的话，在web面板里有一个DNS配置</p>
<p><img src="/images/ZTDNS.webp" alt="DNS"></p>
<p>Search Domain里填写你想要解析的域名，再在Server Address里填写DNS服务器的ip就可以</p>
<p>如果你想访问 <code>123.zt</code> 或 <code>www.123.zt</code> ，那么你就可以填写 <code>zt</code> 或 <code>123.zt</code></p>
<p>因为我有一台openwrt软路由，使用的默认的DNS服务器 <code>Dnsmasq</code></p>
<p>所以我没有自己部署过DNS服务器，你需要自己部署一个</p>
<blockquote>
<p>官方控制器一个Server只能同时对应一个Search Domain</p>
</blockquote>
<blockquote>
<p>其实还有很多方案，比如</p>
<ul>
<li>买个域名然后解析到ZeroTier内网地址</li>
<li>分发hosts文件</li>
<li>修改本地DNS配置</li>
</ul>
</blockquote>
<h2 id="局域网联机"><a href="#局域网联机" class="headerlink" title="局域网联机"></a>局域网联机</h2><p>在使用ZeroTier进行局域网联机时有时不能发现其他设备，可以尝试调整 <a href="https://www.techkoala.net/windows_10_network_priority/">Windows 网络连接优先级设置</a></p>
<h2 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h2><p>如果想让网络内的设备像在家里的局域网里一样通过网络内的路由器上网</p>
<p>官方有一篇教程 <a href="https://docs.zerotier.com/exitnode">VPN Exit Node</a></p>
<p>简单来说就是把路由规则设置成以下这样</p>
<p><img src="/images/ZTRoutes.webp" alt="Routes"></p>
<p>然后将终端设备的allowDefault设置为1</p>
<p>Windows的长这样</p>
<p><img src="/images/ZTWindowsConfig.webp" alt="Windows"></p>
<p>官方安卓客户端上长这样</p>
<p><img src="/images/ZTAndroidConfig.webp" alt="Android"></p>
<p>引用一下DeepSeek生成的</p>
<blockquote>
<p>ZeroTier中的<code>allowDefault</code>设置名称源于其功能目的，具体解析如下：</p>
<ol>
<li><strong>命名来源解析</strong>：</li>
</ol>
<ul>
<li><strong>“Default”（默认）</strong>：指代计算机网络中的<strong>默认路由（Default Route）</strong>。默认路由是当目标地址不在其他路由规则中时，数据包选择的路径，通常用于连接互联网（如<code>0.0.0.0/0</code>）。</li>
<li><strong>“Allow”（允许）</strong>：表示该设置是一个权限开关，控制是否<strong>允许ZeroTier修改系统的默认路由</strong>&gt; 。</li>
</ul>
<ol start="2">
<li><strong>功能作用</strong>：</li>
</ol>
<ul>
<li>当<code>allowDefault</code>设置为<code>true</code>时，ZeroTier会将自身的虚拟网络接口（如<code>zt0</code>）添加为系统的默认路由。这意味着<strong>所有未匹配到其他路由规则的流量</strong>（包括互联网访问）都会被导向ZeroTier网络。</li>
<li>若设置为<code>false</code>，则ZeroTier不会干预系统的默认路由，设备通过原有网络接口（如Wi-Fi、以太网）访问互联网。</li>
</ul>
<ol start="3">
<li><strong>典型应用场景</strong>：</li>
</ol>
<ul>
<li><strong>VPN类似功能</strong>：启用<code>allowDefault</code>后，所有流量经过ZeroTier网络，适合需要统一流量出口或加密的场景（如通过企业服务器访问外网）。</li>
<li><strong>隔离网络通信</strong>：禁用此设置时，ZeroTier仅处理与虚拟网络相关的流量（如<code>10.147.17.0/24</code>），其他流量保持本地直连，避免影响正常上网。</li>
</ul>
<ol start="4">
<li><strong>注意事项</strong>：</li>
</ol>
<ul>
<li><strong>潜在风险</strong>：若ZeroTier网络未配置正确出口节点（如缺少公共IP转发），启用<code>allowDefault</code>可能导致设备断网。</li>
<li><strong>配置建议</strong>：通常仅在需要全局流量管控时启用，普通组网场景建议保持关闭，仅通过特定路由规则（如<code>route 0.0.0.0/0 via 网关IP</code>）定向部分流量。</li>
</ul>
<p><strong>示例配置</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 在ZeroTier网络配置的routes部分：</span></span><br><span class="line">&gt;<span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">   <span class="punctuation">&#123;</span> <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.147.17.0/24&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;via&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span> <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="comment">// ZeroTier局域网直连</span></span><br><span class="line">   <span class="punctuation">&#123;</span> <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;via&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.147.17.1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;allowDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span>  <span class="comment">// 默认路由经网关</span></span><br><span class="line"> <span class="punctuation">]</span></span><br><span class="line">&gt;<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此配置中，<code>allowDefault: true</code>允许将<code>10.147.17.1</code>设为默认网关，所有非本地流量通过该节点转发。</p>
<p>总之，<code>allowDefault</code>的命名直观反映了其核心功能：<strong>允许（Allow）ZeroTier接管系统的默认（Default）路由</strong>，这一设计既符合技术术语，也遵循了软件配置的常见命名规范。</p>
</blockquote>
<h2 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h2><p>我认为一般用户没必要看这个，这个东西本身其实是我在摸索的时候走歪的一条路</p>
<p>一般来说直接安装官方包就行</p>
<p>如果实在不行，可以继续看</p>
<p>在 Docker 下安装有三条路</p>
<ul>
<li>部署 <a href="https://hub.docker.com/r/zerotier/zerotier">官方镜像</a></li>
<li>在 Debian 镜像下安装官方包</li>
<li>在 Alpine 镜像下自行编译源码<blockquote>
<p>Alpine 似乎本来是有官方包的，后来被撤了</p>
</blockquote>
</li>
</ul>
<p>第一条路我死活跑不起来，第二条路镜像体积太大</p>
<p>下面是我摸索很久走出来的第三条路</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache curl git make linux-headers openssl-dev pkgconf gcc g++ \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$HOME</span>/.cargo/env&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; git <span class="built_in">clone</span> --branch main --single-branch --depth 1 https://github.com/zerotier/ZeroTierOne.git \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">cd</span> ZeroTierOne \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -j</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache libstdc++ gcompat openssl libgcc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /ZeroTierOne/zerotier-one /usr/sbin/zerotier-one</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /ZeroTierOne/zerotier-cli /usr/sbin/zerotier-cli</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;zerotier-one&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zerotier:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zerotier</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/zerotier-one</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/dev/net/tun:/dev/net/tun</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>构建镜像时的CPU需求量很高，记得放在主力机上构建</p>
<p>这是我试出来的最小配置，不嫌烦的可以自己试试</p>
<p>以及我给了这个容器 privileged 权限，不喜欢的可以自己试试</p>
<p>顺带一提，我现在用的是 OpenWrt 仓库里的软件包</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>目前这套解决方案对于我来说已经足够了，所以我没有仔细研究过其他的解决方案</p>
<p>虽然东西看上去不多，但是折磨了我很久，我没能找到一篇能从头到尾给我讲明白的文章</p>
<p>(其实现在也讲得不太明白，以后可能还会回来更新)</p>
<p>这篇文章也引用了很多别人的东西，我不觉得我能讲得比别人好</p>
<p>我很感谢他们，希望我也能帮助到你</p>
<p>总之我写了这篇文章，如果有帮到你或者你有什么需要补充的，可以给我发个邮件提个 issue 什么的</p>
]]></content>
  </entry>
  <entry>
    <title>Rootless Podman Quadlet 搭建记录</title>
    <url>/zh-CN/2025/container-podman/</url>
    <content><![CDATA[<blockquote>
<p>注意本文可能具有很强的时效性，请自行查证</p>
</blockquote>
<p>最近把容器后端从 Docker 切换到了 Podman ，记录一下受到的折磨。</p>
<span id="more"></span>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Zero trust 安全模型里面有个 Least privilege ，简单来说就是只给程序运行所需要的权限，Docker 的容器毕竟都是 root 用户运行的，不太好。</p>
<p>Podman 与 Docker 最大的不同就是没有一个中心的进程去管理容器们，这也导致 Podman 需要使用 Systemd 这种服务管理器来实现容器的开机自启，这也是 Quadlet 存在的原因中的一部分。</p>
<p>没了中心进程也让系统中的非 root 用户也可以直接创建自己的容器。</p>
<p>Docker 有 Docker compose 来简单地做一些容器的编排工作，我之前就写了十几个 compose.yaml 然后把他们 include 到一个文件里去，差不多像这样：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./service1/compose.yaml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./service2/compose.yaml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./service3/compose.yaml</span></span><br><span class="line">  <span class="comment"># - ./service4/compose.yaml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./service5/compose.yaml</span></span><br></pre></td></tr></table></figure>

<p>这导致我在使用 Podman compose 的时候会突然在神秘的地方出现神秘的空文件夹，或者容器不停报错重启，非常折磨。</p>
<p>这是因为 Podman compose 跟 Docker compose 对 include 的相对路径的处理方式不同导致的，前者是完全按你在哪执行 compose up 指令来算，而后者是看 compose.yaml 文件的路径来决定的。</p>
<blockquote>
<p>最开始决定使用 Podman 是因为他对 nftables 的支持，虽然目前我似乎完全没看见他有写防火墙规则</p>
</blockquote>
<p>我实在是对这种重复劳动没啥兴趣，在进行了几天的检索之后我决定直接全部切换到 Quadlet 配置文件来管理。</p>
<p>Rootless 和 Rootful 的区别确实大，主要是容器内对宿主机的权限映射问题和 Linux 里的权限管理问题。</p>
<h1 id="Podman"><a href="#Podman" class="headerlink" title="Podman"></a>Podman</h1><p>Podman 在设计时决定了用户与用户之间互不影响，从 Network 和 Pod 这种用来让容器们互相交流的东西居然不能互通这点就能看出来。</p>
<blockquote>
<p>这里我真查得昏天暗地，问 AI 也不行，就像完全没人在意这个问题一样，最后给我翻到了这个 <a href="https://github.com/containers/podman/discussions/20408">https://github.com/containers/podman/discussions/20408</a></p>
<blockquote>
<p>This is not possible,</p>
</blockquote>
<p>给我气傻了当时</p>
</blockquote>
<p>不同用户的容器间通讯只能通过绑定宿主机的端口来进行，或者你也可以把需要相互通讯的容器放到同一个用户下运行。</p>
<p>Podman 中的 Network 和 Pod 的用处差得挺多的，区别在前者类似用来装节点的局域网，后者像局域网里的节点。</p>
<p>Network 可以给 Container 设置也可以给 Pod 设置， Pod 可以给 Container 设置，同一个 Pod 下的 Container 共用端口和 IP 。</p>
<p>Podman 会给所有用户创建一个默认 Network 叫 <code>podman</code> ，这个网络没有内置 DNS 不能解析容器名，具体可以用 <code>podman inspect podman</code> 来看到网络的配置，其他网络也可以用这个指令。</p>
<p>Podman 的许多配置都在 <code>/etc/contaiers/containers.conf</code> 底下，比如这个默认网络的网段和名字，我倒是没找到他的 DNS 的配置。</p>
<p>Quadlet 与直接运行 <code>podman run</code> 没有本质上的区别，只是一个持久化的配置文件，这也意味着你在配置 Quadlet 时需要去查 <code>podman run</code> 的文档。</p>
<h1 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h1><p>Rootless 的容器你总不能拿 root 用户跑对吧？需要新建一个用来跑容器的用户，来看指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -b /opt -m -s /usr/bin/nologin -U nginx_container</span><br></pre></td></tr></table></figure>

<p><code>-b /opt</code> 用户 home 目录的基础路径，会在 <code>/opt/nginx_container</code> 生成用户的 home 目录。</p>
<p><code>-m</code> 生成 home 目录。</p>
<p><code>-s /usr/bin/nologin</code> 用户的登录 shell ，这个 shell 会阻止用户登录，sudo 什么的倒是能用就是了。</p>
<p><code>-U</code> 生成同名用户组。</p>
<p>需要注意的是 Podman 默认会把容器内的 root 用户映射为宿主机运行容器的用户，你在把宿主机的文件映射进去的时候如果运行容器的用户权限不够是无法访问的。</p>
<p>最常见的比如像证书私钥这种需要多容器访问的文件会把所有需要权限的用户添加到这个文件的拥有组里，这时候用户会有两个及以上的组，而 Podman 默认不会处理这种情况。</p>
<p>如果需要访问这样的文件，需要根据你的容器运行时来做不同的处理。</p>
<p>容器运行时可以通过运行 <code>podman info</code> 查看，在 <code>ociRuntime:</code> 项下。</p>
<p>如果是 crun 的话可以在容器启动时加上 <code>--userns=keep-id --group-add=keep-groups</code> 来保证将所有宿主用户的组映射进去，没有 <code>--userns</code> 的话 <code>--group-add=keep-groups</code> 不会生效。</p>
<blockquote>
<p>这个指令的实现方式说是跳过了创建容器时的一个阶段，我看不太懂，可以自行检索一下</p>
<p>也是因为这个原因 runc 容器运行时并不支持 <code>--group-add=keep-groups</code> ，目前只有 crun 支持这个选项</p>
<p><a href="https://github.com/opencontainers/runc/issues/4642">https://github.com/opencontainers/runc/issues/4642</a></p>
<p>runc 的 star 数要比 crun 高，但前者是 go 写的后者是 c 写的，前者速度没有后者快，但他的速度只体现在容器启动的时候，我个人推荐 runc ，原因请看他们的 github releases 页</p>
<p><a href="https://github.com/opencontainers/runc/releases">https://github.com/opencontainers/runc/releases</a></p>
</blockquote>
<p>runc 就比较麻烦点，看下面的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># usermod --add-subgids 1234-1234 container_user</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;container_user:1234:1&quot;</span> &gt;&gt; /etc/subgid \</span><br><span class="line">&amp;&amp; <span class="built_in">sudo</span> -u container_user podman system migrate \</span><br><span class="line">&amp;&amp; <span class="built_in">sudo</span> -u container_user podman unshare <span class="built_in">cat</span> /proc/self/gid_map \</span><br><span class="line">&amp;&amp; <span class="built_in">sudo</span> -u container_user podman run --<span class="built_in">rm</span> --group-add=1234 --gidmap=+g1234:@1234 alpine <span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p><code>echo &quot;container_user:1234:1&quot; &gt;&gt; /etc/subgid</code> 添加可以使用的 subgid ，意思是从1234开始数1个，也就是只有1234一个，注释那个是从1234到1234的意思。</p>
<p><code>sudo -u container_user podman system migrate</code> 刷新。</p>
<p><code>sudo -u container_user podman unshare cat /proc/self/gid_map</code> 查看可用 gid ，第二列是开始的地方，第三列是数几个。</p>
<p><code>sudo -u container_user podman run --rm --group-add=1234 --gidmap=+g1234:@1234 alpine id</code> 先给容器内用户添加组 1234 ，然后将宿主机上的组映射进去。</p>
<p><code>--gidmap=+g1234:@1234</code> <code>+</code> 是指附加在前一个 gidmap 上，<code>g</code> 是限制只添加组，当 <code>uidmap</code> 和 <code>gidmap</code> 只有一个时会默认两个都映射， <code>@</code> 的意思是不删除默认映射的组和用户。</p>
<p>**注意：**添加了这个映射的容器不需要宿主用户在这个 gid 的组里也可以访问这个组拥有的文件。</p>
<blockquote>
<p>这些文档里都有，但实在难找，刷新的那条指令还是我在试了十几遍在报错信息里找到的</p>
<p>虽然麻烦但好像这才是标准操作</p>
</blockquote>
<p>如果用了 <code>--userns=keep-id</code> 的话这时候容器内的用户就不再是 root 了，而是宿主机上运行容器的用户，这会导致很多没有考虑过 Rootless 情况的容器出现问题，可能需要一定的取舍。</p>
<blockquote>
<p>其实可以改成这样 <code>--userns=keep-id:uid=0 --group-add=keep-groups</code> ，这样容器里就是 root 用户带宿主权限组了，能用是能用但我不确定这是不是预期的用法，最好还是直接处理一下容器</p>
</blockquote>
<p>容器里的 Linux 也是 Linux ，没什么太大区别，这也意味着如果你容器里用的不是 root 账户也会遇到容器里的权限问题，比如绑定不了1024以下的端口一类的。</p>
<p>将非 root 用户可以使用的最低端口设置为0：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_unprivileged_port_start=0</span><br></pre></td></tr></table></figure>

<p>宿主机上持久化设置需要写入 <code>/etc/sysctl.d/*.conf</code> ，具体以自己的系统为准。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_unprivileged_port_start=0</span><br></pre></td></tr></table></figure>
<p>Podman 中直接加上 <code>--sysctl</code> 就行，底下有写。</p>
<h1 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h1><p>Quadlet 生成的是 Systemd 的配置文件，这也意味着你也得懂一点 Systemd 。</p>
<blockquote>
<p>我真不懂</p>
</blockquote>
<p>主要就是用 <code>systemctl -M contaier_username@ --user start container_name</code> 启动容器然后 <code>systemctl -M contaier_username@ --user stop container_name</code> 停止容器。</p>
<p>Quadlet里也支持你去设置 <code>reload</code> 指令的具体实现。</p>
<p><code>journalctl -b</code> 看容器的日志，具体的过滤什么的自己 help 看。</p>
<p>如果容器启动了之后自己停了一般是因为没有使用 <code>systemctl enable-linger user</code> 把 linger 打开，防止用户的最后一个 shell 消失之后 Systemd 自己停了。</p>
<p>可以 <code>ls /var/lib/systemd/linger</code> 看哪些人开了 linger 。</p>
<p>不能在 Systemd 这里把容器服务设置为开机自启， Quadlet 里可以设置。</p>
<h1 id="Quadlet"><a href="#Quadlet" class="headerlink" title="Quadlet"></a>Quadlet</h1><p>Qaudlet 是用于生成 Systemd unit 的一种配置文件，在 <code>systemctl daemon-reload</code> 时会读取特定路径下的特定后缀文件来生成 unit 配置，具体的可以直接 <code>man podman-systemd.unit</code> 来看，我这里给简单介绍下。</p>
<p>可以写一些和 Systemd 的 unit 一样的配置。</p>
<p>来看一个 rootless 的 nginx 容器配置：</p>
<blockquote>
<p>nginx.container</p>
</blockquote>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[Container]</span></span><br><span class="line"><span class="attr">ContainerName</span>=nginx</span><br><span class="line"><span class="attr">Image</span>=docker.io/nginx:<span class="number">1.29</span></span><br><span class="line"><span class="attr">Network</span>=podman</span><br><span class="line"><span class="attr">PublishPort</span>=<span class="number">80</span>:<span class="number">80</span></span><br><span class="line"><span class="attr">PublishPort</span>=<span class="number">443</span>:<span class="number">443</span></span><br><span class="line"><span class="attr">Volume</span>=/opt/nginx_container/data:/etc/nginx</span><br><span class="line"><span class="attr">Volume</span>=/var/opt/certs:/etc/nginx/certs</span><br><span class="line"><span class="attr">PodmanArgs</span>=--userns=keep-id --group-add=keep-groups</span><br><span class="line"><span class="attr">PodmanArgs</span>=--sysctl net.ipv4.ip_unprivileged_port_start=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=default.target</span><br></pre></td></tr></table></figure>

<p><code>ContainerName</code> 控制容器名与同一网络下的 Podman 提供的 DNS 解析名</p>
<p><code>Network</code> 容器所属的网络，一般为 <code>host</code> <code>podman</code> 或者 <code>none</code>  ， <code>podman</code> 为 Podman 为每个用户单独创建的不带 DNS 解析的网络，详细的上面写了。</p>
<p><code>PodmanArgs</code> 为 <code>podman run</code> 后面跟着的 flag，详细的上面写了。</p>
<p>这里保留权限主要是为了访问网站的证书，注意 nginx 在 rootless 环境下需要额外配置，可以看 docker 仓库中的 nginx 的简介。</p>
<p>以及这里拆成俩只是因为一行有点长。</p>
<p><code>WantedBy=default.target</code> 设置开机自启，我不懂 Systemd 不知道什么意思。</p>
<p>network pod 啥的配置差不多的自己去查文档 <code>man podman-systemd.unit</code> 。</p>
<h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><blockquote>
<p>这里是 crun 作为容器运行时时的配置，不建议</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -b /opt -m -s /usr/bin/nologin -U nginx_container \</span><br><span class="line">&amp;&amp; <span class="built_in">mkdir</span> /opt/nginx_container/.config \</span><br><span class="line">&amp;&amp; <span class="built_in">mkdir</span> /opt/nginx_container/.config/containers \</span><br><span class="line">&amp;&amp; <span class="built_in">mkdir</span> /opt/nginx_container/.config/containers/systemd \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;[Container]</span></span><br><span class="line"><span class="string">ContainerName=nginx</span></span><br><span class="line"><span class="string">Image=docker.io/nginx:1.29</span></span><br><span class="line"><span class="string">Network=podman</span></span><br><span class="line"><span class="string">PublishPort=80:80</span></span><br><span class="line"><span class="string">PublishPort=443:443</span></span><br><span class="line"><span class="string">Volume=/opt/nginx_container/data:/etc/nginx</span></span><br><span class="line"><span class="string">Volume=/var/opt/certs:/etc/nginx/certs</span></span><br><span class="line"><span class="string">PodmanArgs=--userns=keep-id --group-add=keep-groups</span></span><br><span class="line"><span class="string">PodmanArgs=--sysctl net.ipv4.ip_unprivileged_port_start=0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=default.target&quot;</span> &gt; /opt/nginx_container/.config/containers/systemd/nginx.container \</span><br><span class="line">&amp;&amp; <span class="built_in">chown</span> -R nginx_container:nginx_container /opt/nginx_container \</span><br><span class="line">&amp;&amp; systemctl -M nginx_container@ --user daemon-reload \</span><br><span class="line">&amp;&amp; systemctl enable-linger nginx_container \</span><br><span class="line">&amp;&amp; systemctl -M nginx_container@ --user start nginx \</span><br><span class="line">&amp;&amp; journalctl -b -n 100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是 runc 作为容器运行时的配置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -b /opt -m -s /usr/bin/nologin -U nginx_container \</span><br><span class="line">&amp;&amp; groupadd certs \</span><br><span class="line">&amp;&amp; <span class="built_in">mkdir</span> /opt/nginx_container/.config \</span><br><span class="line">&amp;&amp; <span class="built_in">mkdir</span> /opt/nginx_container/.config/containers \</span><br><span class="line">&amp;&amp; <span class="built_in">mkdir</span> /opt/nginx_container/.config/containers/systemd \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;[Container]</span></span><br><span class="line"><span class="string">ContainerName=nginx</span></span><br><span class="line"><span class="string">Image=docker.io/nginx:1.29</span></span><br><span class="line"><span class="string">Network=podman</span></span><br><span class="line"><span class="string">PublishPort=80:80</span></span><br><span class="line"><span class="string">PublishPort=443:443</span></span><br><span class="line"><span class="string">Volume=/opt/nginx_container/data:/etc/nginx</span></span><br><span class="line"><span class="string">Volume=/var/opt/certs:/etc/nginx/certs</span></span><br><span class="line"><span class="string">PodmanArgs=--group-add=<span class="subst">$(id -g certs)</span> --gidmap=+g<span class="subst">$(id -g certs)</span>:@<span class="subst">$(id -g certs)</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=default.target&quot;</span> &gt; /opt/nginx_container/.config/containers/systemd/nginx.container \</span><br><span class="line">&amp;&amp; <span class="built_in">chown</span> -R nginx_container:nginx_container /opt/nginx_container \</span><br><span class="line">&amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;nginx_container:<span class="subst">$(id -g certs)</span>:1&quot;</span> &gt;&gt; /etc/subgid \</span><br><span class="line">&amp;&amp; <span class="built_in">sudo</span> -u nginx_container podman system migrate \</span><br><span class="line">&amp;&amp; <span class="built_in">sudo</span> -u nginx_container podman unshare <span class="built_in">cat</span> /proc/self/gid_map \</span><br><span class="line">&amp;&amp; <span class="built_in">sudo</span> -u nginx_container podman run --<span class="built_in">rm</span>  alpine <span class="built_in">id</span> \</span><br><span class="line">&amp;&amp; systemctl -M nginx_container@ --user daemon-reload \</span><br><span class="line">&amp;&amp; systemctl enable-linger nginx_container \</span><br><span class="line">&amp;&amp; systemctl -M nginx_container@ --user start nginx \</span><br><span class="line">&amp;&amp; journalctl -b -n 100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反正不是复制下来一运行就能用的脚本就是了哈哈 主要是看看需要干什么</p>
</blockquote>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>我也不知道我在干什么</p>
<p>还挺烦的这套流程， 怀念 docker compose 随便写两下就能跑的感觉</p>
<p>总之如果有发现错误欢迎来仓库发个 issue</p>
<blockquote>
<p>2025-11-28</p>
</blockquote>
<p>不是哥们， crun 的依赖里面怎么能有 wayland pipewire mesa 这堆东西的？吓得我直接换 runc 了</p>
<p>所以说libkrun 为什么会依赖图形类的运行库啊？ issue 里也没人提吗？</p>
<p>回来更新一下，看看什么时候有人提这事</p>
]]></content>
  </entry>
  <entry>
    <title>关于Hexo在Github Pages上的搭建</title>
    <url>/zh-CN/2025/AboutHexo/</url>
    <content><![CDATA[<p>记录一下我在Github Page上搭建Hexo的过程</p>
<p><a href="https://hexo.io/docs/index.html">Hexo</a> 的官方文档似乎年久失修了</p>
<p>英文和中文的情况都差不多</p>
<p>但至少是能看的</p>
<blockquote>
<p>截止2025.4.7</p>
</blockquote>
<p>这些是我自己试出来的配置，跟文档里写的不太一样</p>
<p>因为我的环境不方便直接安装，我是在Docker容器中安装的</p>
<span id="more"></span>
<h2 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h2><p>设置连接配置以及信任github公钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .ssh</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>~/website/blog/.ssh/config</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  IdentityFile ~/.ssh/key_blog</span><br><span class="line">  User git</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>~/website/blog/.ssh/known_hosts</code></p>
<p>公钥可以在这里获取 <a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">GitHub 的 SSH 密钥指纹</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本地生成ssh密钥</p>
</blockquote>
<blockquote>
<p>写这篇文章时官方首选的ssh密钥格式是ed25519</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/website/blog</span><br><span class="line">ssh-keygen -t ed25519 -f ./key_blog</span><br><span class="line"><span class="built_in">mv</span> key_blog .ssh/</span><br></pre></td></tr></table></figure>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>往 <a href="https://hub.docker.com/_/node">node</a> 镜像里安装Hexo</p>
<blockquote>
<p><code>~/website/blog/Dockerfile</code></p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">23</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /blog</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install -g hexo-cli \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; hexo init \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; npm install hexo-theme-next \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; npm install hexo-server --save \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; npm install hexo-deployer-git --save \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; npm install hexo-generator-searchdb \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apk add --no-cache git openssh-client \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; git config --global user.name <span class="string">&quot;Jinenze&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; git config --global user.email <span class="string">&quot;admin@jinenze.xyz&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> .ssh /root/.ssh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;hexo&quot;</span>,<span class="string">&quot;server&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><a href="https://theme-next.js.org/docs/getting-started/">hexo-theme-next</a></li>
<li><a href="https://hexo.io/docs/server">hexo-server</a></li>
<li><a href="https://hexo.io/docs/one-command-deployment">hexo-deployer-git</a></li>
<li><a href="https://theme-next.js.org/docs/third-party-services/search-services">hexo-generator-searchdb</a></li>
</ul>
<p>记得把名字和邮箱地址换了</p>
<p><code>COPY</code> 的目标路径记得写绝对路径，不然你会看到一个名叫 <code>~</code> 的文件夹</p>
<p>关于 <code>CMD</code> 和 <code>ENTRYPOINT</code></p>
<ul>
<li><a href="https://docs.docker.com/reference/dockerfile/#entrypoint">ENTRYPOINT</a></li>
<li><a href="https://docs.docker.com/reference/dockerfile/#shell-and-exec-form">Shell and exec form</a></li>
<li><a href="https://docs.docker.com/reference/compose-file/services/#init">init</a></li>
</ul>
<p>顺带一提，页面生成与生成后的上传可以放到Github Actions上完成</p>
<p>那样就不需要 <code>hexo-deployer-git</code> 和 <code>git</code> 了</p>
<p>详细看左边的Github Actions那栏</p>
</blockquote>
<blockquote>
<p><code>~/website/blog/compose.yaml</code></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">blog:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">blog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># - VIRTUAL_HOST=blog.jinenze.xyz</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="comment"># expose:</span></span><br><span class="line">    <span class="comment">#   - 4000</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="comment"># networks:</span></span><br><span class="line">    <span class="comment">#   - nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">4000</span><span class="string">:4000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/_config.yml:/blog/_config.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/_config.next.yml:/blog/_config.next.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/source:/blog/source</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注释掉的是 <a href="https://hub.docker.com/r/nginxproxy/nginx-proxy">nginx-proxy</a> 配置，一个自动写nginx配置的项目</p>
<p>默认端口是4000，可以通过在compose文件末尾加上 <code>command: [&quot;-p&quot;,&quot;端口&quot;]</code> 来更改</p>
<p>如果映射出来的都是空文件记得先注释掉 <code>volumes</code> 然后 <code>docker cp blog:/blog ./data</code> 一下</p>
</blockquote>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>设置仓库地址</p>
<blockquote>
<p><code>~/website/blog/data/_config.yml</code></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:YourName/YourRepository.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般在文件末尾</p>
<p><code>repo</code> 换成你仓库ssh地址</p>
</blockquote>
<blockquote>
<p><code>~/website/blog/deploy.sh</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> blog sh -c <span class="string">&quot;</span></span><br><span class="line"><span class="string">  hexo clean \</span></span><br><span class="line"><span class="string">  &amp;&amp; hexo g -d</span></span><br><span class="line"><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>hexo clean</code> 会删除 <code>public</code> 文件夹和 <code>db.json</code></p>
</blockquote>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>新建仓库，名称随意</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/website/blog</span><br><span class="line"><span class="built_in">cat</span> key_blog.pub</span><br></pre></td></tr></table></figure>
<p><code>Settings &gt; Deploy keys &gt; Add deploy key</code> 把 <code>key_blog.pub</code> 的内容添加到deploy key里</p>
<p><code>Settings &gt; Pages</code> 改成 <code>Deploy from a branch</code></p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/website/blog</span><br><span class="line">docker compose up</span><br></pre></td></tr></table></figure>
<p>就可以启动容器了</p>
<p>需要注意alpine镜像默认没有bash，进入容器调试要用sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it blog sh</span><br></pre></td></tr></table></figure>
<p>到这里就可以开始写配置文件和文章了</p>
<p>文章放到 <code>source/_posts</code> 文件夹里</p>
<p>配置文件就是 <code>volumes</code> 映射出来的那些</p>
<p>下面是提醒</p>
<p><code>source</code> 文件夹下的文件夹会出现在网站根目录</p>
<p>在<code>source</code> 文件夹里放一个 <code>CNAME</code> 文件</p>
<p>在里面写上你的域名，最后把域名DNS解析到你的github域名就可以用自定义域名访问你的博客了</p>
<blockquote>
<p>不知道你的github域名的话可以在放上文件后在 <code>Settings &gt; Pages</code> 里等他验证一下DNS</p>
<p>没验证到就会提醒你改DNS解析记录</p>
</blockquote>
<p>可以在 <code>source/images</code> 下面存图片，用 <code>/images/name</code> 调用</p>
<p>记得注意图片大小，Github Pages还是有限制流量的</p>
<p><code>_posts</code> 目录是存放文章的默认路径</p>
<p><code>_posts</code> 目录下的所有md文件开头必须拥有一个 <a href="https://hexo.io/docs/front-matter">Front Matter</a> ，不然不会显示在网站里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Next有对Front Matter进行扩展，点 <a href="https://theme-next.js.org/docs/advanced-settings/front-matter">这里</a></p>
</blockquote>
<p>下面的是个标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<p>如果用户在首页，在这个标签下面的东西会被隐藏并显示一个阅读全文的按钮</p>
<p>得记得这玩意上面一行不要写字，不然那行字和底下的按钮会变大</p>
<p><code>_posts</code> 目录下的md文件更改时会直接同步到测试服务器上</p>
<p><code>_config</code> 开头的文件不会，更改的时候直接 <code>docker compose restart blog</code></p>
<p><code>_config</code> 开头的文件看文档编写</p>
<ul>
<li><a href="https://hexo.io/docs/configuration">Hexo</a> <code>_config.yml</code></li>
<li><a href="https://theme-next.js.org/docs/theme-settings/">Next</a> <code>_config.next.yml</code></li>
<li>Next <a href="https://theme-next.js.org/docs/third-party-services/search-services">Local Search</a></li>
</ul>
<blockquote>
<p>官方文档里对 <code>language</code> 项的描述。。。只能说写了，看 <a href="https://theme-next.js.org/docs/theme-settings/internationalization">Next的文档</a></p>
</blockquote>
<p>最好不要把 <code>_config.yml</code> 里的 <code>permalink</code> 项改成 <code>:title/</code></p>
<p>这样会把所有 <code>_posts</code> 里的文章全部丢进根目录</p>
<p>我写的是 <code>:lang/:year/:title/</code></p>
<p>需要在每篇文章的 <code>Front Matter</code> 里指定 <code>lang</code> ，或者看官方文档 <a href="https://hexo.io/docs/internationalization#Path">i18n Path</a> 配置默认设置</p>
<p>不然文章会出现在一个叫未定义的路径里</p>
<blockquote>
<p>之后可能会详细写一下怎么配置</p>
</blockquote>
<blockquote>
<p>评论和统计数据需要第三方服务，之后再说</p>
</blockquote>
<p>记得看别人是怎么配置的，也可以看看官方文档的配置</p>
<p>这个方案不会把网站的源配置挂在Github上，而且不会有历史提交记录</p>
<p>如果你不喜欢可以看下面的配置</p>
<h2 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h2><blockquote>
<p><code>~/website/blog/data/.github/workflows/deploy.yml</code></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-22.04</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;23&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install -g hexo-cli</span></span><br><span class="line"><span class="string">          hexo init</span></span><br><span class="line"><span class="string">          npm install hexo-theme-next</span></span><br><span class="line"><span class="string">          npm install hexo-generator-searchdb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Download</span> <span class="string">Source</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git clone --branch main --single-branch --depth 1 https://github.com/Jinenze/blog.git tmp-repo</span></span><br><span class="line"><span class="string">          rm -r source</span></span><br><span class="line"><span class="string">          cp -r tmp-repo/* .</span></span><br><span class="line"><span class="string">          rm -r tmp-repo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>
<p>这样配置时，当你推送代码到 <code>main</code> 分支的时候，会触发这个action</p>
<p>这样配置时就不需要在容器里安装 <code>git</code> 了，直接在宿主机把 <code>data</code> 文件夹上传到你仓库的 <code>main</code> 分支就行</p>
<p>部署时默认部署在 <code>gh-pages</code> 分支，记得把Github Page部署的 <code>branch</code> 换了</p>
]]></content>
  </entry>
</search>
